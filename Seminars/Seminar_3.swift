import UIKit
// Блок 1
//Задачи:
//1. Создать массив [5, 6, -14, 25], а затем создать новую переменную с отсортированным по возрастанию ранее созданным массивом.
//Используем три вида сортировки
let arr = [5, 6, -14, 25]
var secondArr = arr.sorted()
var thirdArr = arr.sorted(by: >)
var fourthArr = arr.sorted { $0 < $1 }

//Создать массив,  а затем создать переменную, в которой будет хранится ранее созданные массив, но в нем каждое значение должно быть увеличено на 5.
let anotherArr = [5, 6, -14, 25]
var newArr = anotherArr.map { $0 + 5 }

//Создать массив,  а затем создать переменную, в которой будет хранится ранее созданные массив, но в нем не должно быть ни отрицательных чисел, ни числа 12, а также каждое значение должно быть увеличено в 2 раза.
var arrAA = arr.map { $0 * 2 }.filter { $0 >= 0 && $0 != 12}

//Создать словарь, в котором ключ будет целым числом, а значение строкой
let dic: Dictionary<Int, String> = [:]
let dic1: [Int:String] = [:]

//Создать массив [2, 6, 25, 4, 2, 2, 10, 2], затем создать новую переменную, в которой будут те же значения, что и в ранее созданном массиве, но не должно быть повторяющихся значений.
let newArrr = [2, 6, 25, 4, 2, 2, 10, 2]
let set = Array(Set(newArrr))

//Написать функцию, которая на вход принимает массив целых чисел, а возвращает true или false. true, если результат сложения всех чисел массива больше или равно 100, false, если меньше 100
func sum(_ array: [Int]) -> Bool {
    array.reduce(0, +) >= 100
}

//Создать переменную, в которой будет хранится замыкание, в которое передается словарь с ключом типа Int и значением типа String, а в ходе выполнения замыкания в консоль печатаются все значения словаря, ключ у которых больше 5
var closure = {(name: [Int: String]) in
    for (key, value) in name where key > 5 {
        print(value)
    }
}
closure(dic)


// 2 блок
//Задачи:
//Создать перечисление, которое имеет в виде кейсов три вида чая: зеленый, черный и фруктовый. Затем создать словарь, в котором ключ это вид чая, а значение это стоимость и заполнить этот словарь.

enum Tea {
    case green
    case black
    case fruit
}
let teaDic: [Tea: Double] = [.black: 10, .green: 21, .fruit: 12]

//Написать функцию, которая на вход принимает такой же словарь, как в задании 1, а возвращает новый, который создан по следующим правилам: у фруктового чая стоимость должна быть увеличена на 30%, у черного уменьшена в 1.6 раза, а у зеленого уменьшена на 9.5%
func shop(_ pack: [Tea: Double]) -> [Tea: Double] {
    var packDic: [Tea: Double] = [:] //создаем пустой словарь
    for (key, value) in pack { //проходим по каждым пунктам словаря - ключ-значение
        switch key {
        case .black:
            packDic.updateValue(value / 1.6, forKey: key)
        case .green:
            packDic.updateValue(value - 9.5, forKey: key)
        case .fruit:
            packDic.updateValue(value / 3, forKey: key)
        }
        
    }
    return packDic
}
shop(teaDic)

//Написать функцию, которая на вход принимает два целочисленных массива, которые содержат координаты начала и конца отрезка соответственно. Первый элемент массива это x, а второй y. Функция должна вернуть массив, который содержит координаты середины отрезка
func mapOfWay(_ start: [Int], _ finish: [Int]) -> [Int] {
    guard start.count == 2 && finish.count == 2 else { //количество элементов получаем при помощи каунт
    return [] //если вдруг их не 2, то возвращаем пустой массив
        
    }
    return [(start[0] + finish[0])/2, (start[1] + finish[1])/2]
}

//Написать функцию, которая на вход принимает массив из 4 целых чисел (если чисел меньше или больше должно вернуться nil). Функция возвращает новый массив, который состоит из 3 элементов, первый элемент это первый элемент переданного массива, второй элемент это сумма второго и третьего элемента (индексы 1 и 2) переданного массива, последний элемент это последний элемент переданного массива. Также этот массив должен быть отсортирован по убыванию.
func arrayGenerator(_ array: [Int]) -> [Int]? {
    guard array.count == 4 else {
        return nil
    }
    return [array[0], array[1] + array[2], array[3]].sorted(by: <)
}
arrayGenerator(newArr)
arrayGenerator(anotherArr)

//Создайте массив, который состоит из всех целых чисел от 1 до 50
let arrray = Array(1...50)

//Напишите замыкание, которое принимает на вход два целых числа и возвращает их сумму, затем вызовите это замыкание
let closuree = {(a: Int, b: Int) in
    a + b
}


//Напишите функцию, которая на вход будет принимать замыкание, которое на вход принимает целое число, но ничего не возвращает. Функция также не должна ничего возвращать. Внутри функции должен печататься тип замыкания
func summ(_ closure: (Int) -> Void) {
    print(type(of: closure))
}
summ({_ in})
summ(){_ in}
summ{_ in}

//Создать массив и при помощи forEach вывести в консоль все значения
arrray.forEach{print($0)}
