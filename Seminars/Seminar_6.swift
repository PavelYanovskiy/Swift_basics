import UIKit

protocol Menu {
    var cost: Double { get set } //если только гет, то мы сможем только получать, если гет сет , то и сможем передавать
    var name: String { get }
}
struct Tea: Menu {
    var name: String {
        type.rawValue + " tea" //написали вычисляемое свойство, оно вычисляет свойство в процессе своего выполнения
    }
    var temperature = 60
    
    enum TeaType: String { //создаем перечисление и все кейсы, которые есть Ти тайп теперь является вложенным в структуру
        case black
        case green
        case fruit
    }

    var type: TeaType
    var cost: Double
    
//    init(type: TeaType) {
//        self.type = type
//
//    }
    
    func getCost(sale: Double) -> Double {
        switch type {
        case .black: return 10
        case .green: return 9
        case .fruit: return 15
        }
    }
        var myTea: Menu = Tea(type: .black, cost: 10)
        print (myTea.cost)
        myTea.cost = 15
    
//Создать класс Person, внутри которого должна быть структура Activity, внутри которой должно быть перечисление TypeOfActivity (тип активности) с тремя кейсами: pupil, student, employee. Создать переменную и явно указать ей тип “тип активности”.
class Person {
    struct Activity {
        enum TypeOfActivity {
            case pupil
            case student
            case employee
        }
    }
}

//класс кафе
class Cafeteria {
    fileprivate var menu: [Menu]
    var owner: ShopOwner //решение из 2 блока ниже
        
    init(owner: ShopOwner, _ menu: [Menu]) { //решение из 2 блока ниже? добавили в инциалиазтор
        self.menu = menu
        self.owner = owner
    }
    
    func add(_ elem: Menu) {
        menu.append(elem)
    }
    
    func showTeaTemp() {
        for elem in menu {
            guard let elem = elem as? Tea else {
                continue //гард требует обязательно континью
            }
            print(elem.temperature)
        }
    }
}
    
    
//Блок 1
//Создайте переменную “a”, в которой будет хранится массив с Tea. Создайте другую переменную “b” и присвойте ей переменную “a”. Выведете в консоль адреса массивов. Затем в “b” добавьте еще один элемент. Выведете в консоль адреса массивов. Объясните полученный результат (можно рядом в комментарии)
var a = [Tea] = []
var b = a
func getAddress(_ collection: UnsafeRawPointer) {
    print(Int(bitPattern: collection))
}

getAddress(a)
getAddress(b)
b.append(Tea(type: .black, cost: 12))
getAddress(a)
getAddress(b)

//Создайте класс, в котором будет одна переменная “test” типа String. Создайте экземпляр класса (название переменной, например, c). Создайте еще одну переменную (название переменной, например, d) и присвойте ей c. В переменной d измените “test”. Выведите в консоль “test” для c и d. Объясните результат

class Test {
    var test: String = ""
}
var c = Test()
var d = c
d.test = "1"
print(c.test)
print(d.test)
//Создайте структуру, в котором будет одна переменная “test” типа String. Создайте переменную, в которой будет лежать структура (название переменной, например, e). Создайте еще одну переменную (название переменной, например, f) и присвойте ей e. В переменной f измените “test”. Выведите в консоль “test” для e и f. Объясните результат
struct Test1 {
    var test: String = "s"
}
var f = Test1()
var e = f
e.test = "e"
print(f.test)
print(e.test)
//Создайте класс магазина. В нем должно быть два массива, один с товарами, второй с работниками. Для работников создайте свою структуру, а для товаров свою. Для товаров должно быть минимум 3 разных структуры, например, еда, напитки и одежда. Добавить в класс функцию, которая будет добавлять работника в массив. Написать функцию, которая будет добавлять новый товар в массив.
   // Добавить в  ранее созданный класс магазина свойство, в котором будет хранится Cafe. Сделать так, чтобы все свойства класса магазина (массив товаров и работников, владелец магазина и кафе) устанавливались в инициализаторе, но в инициализатор передается только массив товаров и работников, а также владелец магазина. Кафе создается внутри инициализатора
    //Написать в классе магазина функцию, которая возвращает меню кафе в виде словаря [<что это>: [массив позиций]], например, в меню есть [чай, чай, лимонад, салат, салат], а вернуть функция должна [“tea”: [чай, чай], “lemonade”: [лимонад], “salad”; [салат, салат] ]. Если для позиции ничего нет (например, нет ни одного лимонада), под ключом должен вернуться пустой массив
class Shop { //класс магазина
    var goods: [Good] //в нем массив с товарами
    var employers: [Employer] // массив с работниками
    var owner: ShopOwner //из следующего задания добавляем владельца магазина
    var cafe: Cafeteria
    
    init(owner: ShopOwner, goods: [Good], employers: [Employer]) { //добавляем инициализатор
    self.owner = owner
    self.goods = goods
    self.employers = employers
        cafe = Cafeteria(owner: owner, [])//раз добавли сюда оунер то и в магазине будет хранится ссылка на объект и владелец уже будет один
    }
    
    func getcafeMenu() -> [String: [Menu]] { //в одной коллекции прячется другая коллеция
        var tea: [Tea] = [] //создаем три пустых массива, а потом проходимся по ним и наполняем каждый
        var lemonade: [Lemonade] = []
        var salad: [Salad] = []
        for elem in cafe.menu {
            if let elem = elem as? Tea {//кладем распакованный элемент
                tea.append(elem)
            } else if let elem = elem as? Lemonade{
                lemonade.append(elem)
            }  else if let elem = elem as? Salad {
                salad.append(elem)
            }
            
        }
        return ["Tea" : tea, "Lemonade" : lemonade, "Salad" : salad]
    }
    //Добавить в класс магазина функцию, которая на основе словаря из предыдущего задания возвращает словарь с теми же ключами, но вместо массива позиций должен быть массив стоимостей этих позиций
    func getPrices() -> [String: [Double]] {
        var positions = getcafeMenu()
        var prices: [String: [Double]] = [:] //создаем словарь, который пока не заполнен
        // проходимся по массиву и создаем массивы стоимости преобразуя массивы позиций
        for elem in positions {
            let price = elem.value.map { $0.cost }
            prices.updateValue(price, forKey: elem.key)
        }
        return prices
    }
    
    func addGood(_ newGood: Good){ //фукнция добавления нового товара
        goods.append(newGood)
    }
    func addEmployer(_ newEmployer: Employer){ //фукнция добавления нового работника
        employers.append(newEmployer)
    }
    
}
}

    
struct Employer { //создаем структуру работников, не пописывая ни на какой протокол
    var Name: String
    var id: Int
}

protocol Good { //создаем проктокол на который будет одновременно подписано три структуры - еда, напитки и одежда
    var price: Double { get set } //и указываем сразу свойства гет и сет
}
struct Food: Good { //подписываем структуру на общий протокол
    var price: Double
    var weight: Int
}

struct Behavior: Good { //подписываем структуру на общий протокол
    var price: Double
}

struct Clother: Good { //подписываем структуру на общий протокол
    var price: Double
    var size: Int
}

//Создать класс владельца магазина. Добавить в него свойство, в котором будет хранится магазин, которым он владеет. А в класс магазина добавить переменную, в которой будет хранится владелец магазина. Ответьте на вопрос: Есть ли в такой связке магазин -> директор и директор -> магазин какая-то проблема? Если да, то какая и как ее решить?

class ShopOwner {
    weak var shop: Shop? // здесь делаем слабую ссылку чтобы не было перезгруза памяти. Директор может без магаза прожить, а магаз без директора  - нет. и обзятельон должен быть опционал
    init(shop: Shop) {
        self.shop
    }
}


//Блок 2
//Задачи:
//С прошлого семинара есть класс Cafe, в котором есть переменная menu, в которую можно добавлять и чай, и лимонад, и салат. Необходимо добавить в структуру чая свойство температуры. Написать функцию в классе Cafe, которая выведет температуру всех Tea из переменной menu.
    

//    добавили выше
    
//Добавить в  ранее созданный класс магазина свойство, в котором будет хранится Cafe. Сделать так, чтобы все свойства класса магазина (массив товаров и работников, владелец магазина и кафе) устанавливались в инициализаторе, но в инициализатор передается только массив товаров и работников, а также владелец магазина. Кафе создается внутри инициализатора
     //добавли в классе кафетериа
    
    
//Добавить в класс кафе свойство, в котором будет хранится владелец кафе. Значение свойству должно устанавливаться в инициализаторе. Когда в классе магазина создается Cafe - владелец и у магазина и у кафе должен быть один.
    
    // добавили решение в кафетерию выше
    
//Написать в классе магазина функцию, которая возвращает меню кафе в виде словаря [<что это>: [массив позиций]], например, в меню есть [чай, чай, лимонад, салат, салат], а вернуть функция должна [“tea”: [чай, чай], “lemonade”: [лимонад], “salad”; [салат, салат] ]. Если для позиции ничего нет (например, нет ни одного лимонада), под ключом должен вернуться пустой массив
    
    //решение выше
    
//Добавить в класс магазина функцию, которая на основе словаря из предыдущего задания возвращает словарь с теми же ключами, но вместо массива позиций должен быть массив стоимостей этих позиций

//решение выше

